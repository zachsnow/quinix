// Quinix Graphics Library
// Provides bitmap font, drawing primitives, and display helper functions.

namespace graphics {
  // RGBA color helpers (format: 0xAARRGGBB for SDL compatibility)
  function rgba(r: byte, g: byte, b: byte, a: byte): byte {
    return (a << 24) | (r << 16) | (g << 8) | b;
  }

  function rgb(r: byte, g: byte, b: byte): byte {
    return rgba(r, g, b, 0xFF);
  }

  // Common colors (format: 0xAARRGGBB)
  namespace color {
    .constant global BLACK: byte = 0xFF000000;
    .constant global WHITE: byte = 0xFFFFFFFF;
    .constant global RED: byte = 0xFFFF0000;
    .constant global GREEN: byte = 0xFF00FF00;
    .constant global BLUE: byte = 0xFF0000FF;
    .constant global YELLOW: byte = 0xFFFFFF00;
    .constant global CYAN: byte = 0xFF00FFFF;
    .constant global MAGENTA: byte = 0xFFFF00FF;
    .constant global GRAY: byte = 0xFF808080;
  }

  // Framebuffer structure for drawing operations
  type framebuffer = struct {
    pixels: *byte;
    width: byte;
    height: byte;
  };

  // Set a single pixel
  function set_pixel(fb: *framebuffer, x: byte, y: byte, color: byte): void {
    if (x >= fb->width || y >= fb->height) {
      return;
    }
    fb->pixels[unsafe y * fb->width + x] = color;
  }

  // Get a single pixel
  function get_pixel(fb: *framebuffer, x: byte, y: byte): byte {
    if (x >= fb->width || y >= fb->height) {
      return 0;
    }
    return fb->pixels[unsafe y * fb->width + x];
  }

  // Clear framebuffer to a color
  function clear(fb: *framebuffer, color: byte): void {
    var size = fb->width * fb->height;
    for (var i: byte = 0; i < size; i = i + 1) {
      fb->pixels[unsafe i] = color;
    }
  }

  // Draw horizontal line
  function hline(fb: *framebuffer, x: byte, y: byte, w: byte, color: byte): void {
    if (y >= fb->height) {
      return;
    }
    var x2 = x + w;
    if (x2 > fb->width) {
      x2 = fb->width;
    }
    for (var i = x; i < x2; i = i + 1) {
      fb->pixels[unsafe y * fb->width + i] = color;
    }
  }

  // Draw vertical line
  function vline(fb: *framebuffer, x: byte, y: byte, h: byte, color: byte): void {
    if (x >= fb->width) {
      return;
    }
    var y2 = y + h;
    if (y2 > fb->height) {
      y2 = fb->height;
    }
    for (var j = y; j < y2; j = j + 1) {
      fb->pixels[unsafe j * fb->width + x] = color;
    }
  }

  // Draw line using Bresenham's algorithm
  function line(fb: *framebuffer, x0: byte, y0: byte, x1: byte, y1: byte, color: byte): void {
    // Handle horizontal and vertical lines efficiently
    if (y0 == y1) {
      if (x0 > x1) {
        var tmp = x0;
        x0 = x1;
        x1 = tmp;
      }
      hline(fb, x0, y0, x1 - x0 + 1, color);
      return;
    }
    if (x0 == x1) {
      if (y0 > y1) {
        var tmp = y0;
        y0 = y1;
        y1 = tmp;
      }
      vline(fb, x0, y0, y1 - y0 + 1, color);
      return;
    }

    // Bresenham's line algorithm
    var dx: byte = x1 > x0 ? x1 - x0 : x0 - x1;
    var dy: byte = y1 > y0 ? y1 - y0 : y0 - y1;
    var sx: byte = x0 < x1 ? 1 : -1;
    var sy: byte = y0 < y1 ? 1 : -1;
    var err: byte = dx - dy;

    while (true) {
      set_pixel(fb, x0, y0, color);
      if (x0 == x1 && y0 == y1) {
        break;
      }
      var e2: byte = 2 * err;
      if (e2 > 0 - dy) {
        err = err - dy;
        x0 = x0 + sx;
      }
      if (e2 < dx) {
        err = err + dx;
        y0 = y0 + sy;
      }
    }
  }

  // Draw rectangle outline
  function rect(fb: *framebuffer, x: byte, y: byte, w: byte, h: byte, color: byte): void {
    hline(fb, x, y, w, color);
    hline(fb, x, y + h - 1, w, color);
    vline(fb, x, y, h, color);
    vline(fb, x + w - 1, y, h, color);
  }

  // Draw filled rectangle
  function fill_rect(fb: *framebuffer, x: byte, y: byte, w: byte, h: byte, color: byte): void {
    for (var j: byte = 0; j < h; j = j + 1) {
      hline(fb, x, y + j, w, color);
    }
  }

  // Draw circle outline using midpoint circle algorithm
  function circle(fb: *framebuffer, cx: byte, cy: byte, r: byte, color: byte): void {
    var x: byte = r;
    var y: byte = 0;
    var d: byte = 1 - r;

    while (x >= y) {
      set_pixel(fb, cx + x, cy + y, color);
      set_pixel(fb, cx - x, cy + y, color);
      set_pixel(fb, cx + x, cy - y, color);
      set_pixel(fb, cx - x, cy - y, color);
      set_pixel(fb, cx + y, cy + x, color);
      set_pixel(fb, cx - y, cy + x, color);
      set_pixel(fb, cx + y, cy - x, color);
      set_pixel(fb, cx - y, cy - x, color);
      y = y + 1;
      if (d <= 0) {
        d = d + 2 * y + 1;
      } else {
        x = x - 1;
        d = d + 2 * y - 2 * x + 1;
      }
    }
  }

  // Draw filled circle using midpoint circle algorithm with horizontal spans
  function fill_circle(fb: *framebuffer, cx: byte, cy: byte, r: byte, color: byte): void {
    var x: byte = r;
    var y: byte = 0;
    var d: byte = 1 - r;

    // Draw center horizontal line
    hline(fb, cx - r, cy, 2 * r + 1, color);

    while (x >= y) {
      y = y + 1;
      if (d <= 0) {
        d = d + 2 * y + 1;
      } else {
        // x decreased: draw wide spans for the previous x
        hline(fb, cx - x, cy + y - 1, 2 * x + 1, color);
        hline(fb, cx - x, cy - y + 1, 2 * x + 1, color);
        x = x - 1;
        d = d + 2 * y - 2 * x + 1;
      }
      if (x >= y) {
        hline(fb, cx - y, cy + x, 2 * y + 1, color);
        hline(fb, cx - y, cy - x, 2 * y + 1, color);
      }
    }
  }

  // Blit (copy) a region from one framebuffer to another
  function blit(
    dst: *framebuffer, dx: byte, dy: byte,
    src: *framebuffer, sx: byte, sy: byte,
    w: byte, h: byte
  ): void {
    for (var j: byte = 0; j < h; j = j + 1) {
      for (var i: byte = 0; i < w; i = i + 1) {
        var color = get_pixel(src, sx + i, sy + j);
        set_pixel(dst, dx + i, dy + j, color);
      }
    }
  }

  // 8x8 bitmap font support
  namespace font {
    // Font dimensions
    .constant global WIDTH: byte = 8;
    .constant global HEIGHT: byte = 8;

    // Get font bitmap data for a character (returns pointer to 8 bytes)
    // Each byte is one row, MSB is leftmost pixel
    function get_glyph(c: byte): *byte {
      // Map ASCII to glyph index (printable chars start at 32)
      if (c < 32 || c > 126) {
        c = 32;  // Default to space for unprintable
      }
      var index = c - 32;
      return <unsafe *byte>(<unsafe byte>&FONT_DATA + index * 8);
    }

    // Draw a single character (fast version - no bounds checking)
    function draw_char(fb: *framebuffer, x: byte, y: byte, c: byte, fg: byte, bg: byte): void {
      var glyph = get_glyph(c);
      var width = fb->width;
      var base = y * width + x;
      for (var row: byte = 0; row < 8; row = row + 1) {
        var bits = glyph[unsafe row];
        var offset = base + row * width;
        // Unrolled inner loop for speed
        fb->pixels[unsafe offset + 0] = (bits & 0x80) ? fg : bg;
        fb->pixels[unsafe offset + 1] = (bits & 0x40) ? fg : bg;
        fb->pixels[unsafe offset + 2] = (bits & 0x20) ? fg : bg;
        fb->pixels[unsafe offset + 3] = (bits & 0x10) ? fg : bg;
        fb->pixels[unsafe offset + 4] = (bits & 0x08) ? fg : bg;
        fb->pixels[unsafe offset + 5] = (bits & 0x04) ? fg : bg;
        fb->pixels[unsafe offset + 6] = (bits & 0x02) ? fg : bg;
        fb->pixels[unsafe offset + 7] = (bits & 0x01) ? fg : bg;
      }
    }

    // Draw a string
    function draw_string(fb: *framebuffer, x: byte, y: byte, s: byte[], fg: byte, bg: byte): void {
      var cx = x;
      for (var i: byte = 0; i < len(s); i = i + 1) {
        draw_char(fb, cx, y, s[i], fg, bg);
        cx = cx + 8;
      }
    }

    // 8x8 font data for ASCII 32-126 (95 characters, 760 bytes)
    // Each character is 8 bytes (rows), MSB = left pixel
    global FONT_DATA: byte[760] = [
      // 32: Space
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // 33: !
      0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,
      // 34: "
      0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
      // 35: #
      0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
      // 36: $
      0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00,
      // 37: %
      0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,
      // 38: &
      0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00,
      // 39: '
      0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
      // 40: (
      0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00,
      // 41: )
      0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00,
      // 42: *
      0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
      // 43: +
      0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
      // 44: ,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
      // 45: -
      0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
      // 46: .
      0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
      // 47: /
      0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
      // 48: 0
      0x7C, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0x7C, 0x00,
      // 49: 1
      0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
      // 50: 2
      0x7C, 0xC6, 0x06, 0x1C, 0x30, 0x66, 0xFE, 0x00,
      // 51: 3
      0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00,
      // 52: 4
      0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00,
      // 53: 5
      0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00,
      // 54: 6
      0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00,
      // 55: 7
      0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
      // 56: 8
      0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00,
      // 57: 9
      0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00,
      // 58: :
      0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,
      // 59: ;
      0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,
      // 60: <
      0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00,
      // 61: =
      0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00,
      // 62: >
      0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,
      // 63: ?
      0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00,
      // 64: @
      0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00,
      // 65: A
      0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00,
      // 66: B
      0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00,
      // 67: C
      0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00,
      // 68: D
      0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00,
      // 69: E
      0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00,
      // 70: F
      0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00,
      // 71: G
      0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3A, 0x00,
      // 72: H
      0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00,
      // 73: I
      0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
      // 74: J
      0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00,
      // 75: K
      0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00,
      // 76: L
      0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00,
      // 77: M
      0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
      // 78: N
      0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00,
      // 79: O
      0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
      // 80: P
      0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
      // 81: Q
      0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x06,
      // 82: R
      0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00,
      // 83: S
      0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00,
      // 84: T
      0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x3C, 0x00,
      // 85: U
      0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
      // 86: V
      0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
      // 87: W
      0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00,
      // 88: X
      0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00,
      // 89: Y
      0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00,
      // 90: Z
      0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00,
      // 91: [
      0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00,
      // 92: backslash
      0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,
      // 93: ]
      0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00,
      // 94: ^
      0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
      // 95: _
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
      // 96: `
      0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
      // 97: a
      0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
      // 98: b
      0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00,
      // 99: c
      0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00,
      // 100: d
      0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
      // 101: e
      0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00,
      // 102: f
      0x1C, 0x36, 0x30, 0x78, 0x30, 0x30, 0x78, 0x00,
      // 103: g
      0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x78,
      // 104: h
      0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00,
      // 105: i
      0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,
      // 106: j
      0x06, 0x00, 0x0E, 0x06, 0x06, 0x66, 0x66, 0x3C,
      // 107: k
      0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00,
      // 108: l
      0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
      // 109: m
      0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0x00,
      // 110: n
      0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x00,
      // 111: o
      0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
      // 112: p
      0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0,
      // 113: q
      0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E,
      // 114: r
      0x00, 0x00, 0xDC, 0x76, 0x60, 0x60, 0xF0, 0x00,
      // 115: s
      0x00, 0x00, 0x7C, 0xC0, 0x7C, 0x06, 0xFC, 0x00,
      // 116: t
      0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00,
      // 117: u
      0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
      // 118: v
      0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
      // 119: w
      0x00, 0x00, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00,
      // 120: x
      0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00,
      // 121: y
      0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0xFC,
      // 122: z
      0x00, 0x00, 0xFE, 0x8C, 0x18, 0x32, 0xFE, 0x00,
      // 123: {
      0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00,
      // 124: |
      0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
      // 125: }
      0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00,
      // 126: ~
      0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ];
  }
}
